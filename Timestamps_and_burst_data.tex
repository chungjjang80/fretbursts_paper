\subsection{Timestamps and burst data}
\label{sec:burststimes}

Beyond providing prepackaged functions for established methods, 
FRETBursts also provides the infrastructure for exploring new analysis approaches.
Users can easily get timestamps (or selection masks) for any photon stream.
Core burst data (essentially start and stop times and indexes 
and derived quantities for each burst) are stored in a \verb|Bursts| object 
(\href{http://fretbursts.readthedocs.org/en/latest/burstsearch.html}{documentation}).
This object provides a simple and well tested interface (100 \% test coverage) 
to access and manipulate burst data. \verb|Bursts| are created from a sequence of start/stop 
times and indexes, while all the other fields are automatically
computed. \verb|Bursts|'s methods allow to recompute indexes relative to a different photon
selection or recompute start and stop times relative to a new timestamps array.
Additional methods perform fusion of nearby bursts or combination of two set of bursts 
(time intersection or union). This functionality is used fr example to implement 
the dual-channel burst search).
In conclusion, \verb|Bursts| efficiently implements all the common operations performed 
with burst data, providing and easy-to-use interface and well tested algorithms. 
Leveraging \verb|Bursts| methods, users can implement new types of analysis without 
wasting time implementing (and debugging) standard manipulation routines.
Examples of working directly with timestamps, masks (i.e. photon selections) and 
burst data are provided in one of the FRETBursts notebooks (\href{http://nbviewer.jupyter.org/github/tritemio/FRETBursts_notebooks/blob/master/notebooks/Example%20-%20Working%20with%20timestamps%20and%20bursts.ipynb}{link}).

\subsubsection{Python details}
\verb|Bursts| objects internally store the start and stop times and indexes in a numpy array.
The other fields are computed on-fly using class properties, so they are always
up to date even if start and stop are modified. Iteration over bursts is
relatively fast, with performances similar to iterating through numpy rows.

